<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator>
  <link href="https://alexonepath.github.io/tag/docker/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://alexonepath.github.io/" rel="alternate" type="text/html" />
  <updated>2018-12-21T14:20:13+09:00</updated>
  <id>https://alexonepath.github.io/tag/docker/feed.xml</id>

  
  
  

  
    <title type="html">About alex | </title>
  

  
    <subtitle>About alexander</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">Docker Compose</title>
      <link href="https://alexonepath.github.io/category/docker/guide/guide-3-compose.html" rel="alternate" type="text/html" title="Docker Compose" />
      <published>2018-12-21T09:00:00+09:00</published>
      <updated>2018-12-21T09:00:00+09:00</updated>
      <id>https://alexonepath.github.io/category/docker/guide/guide-3-compose</id>
      <content type="html" xml:base="https://alexonepath.github.io/category/docker/guide/guide-3-compose.html">&lt;blockquote&gt;
  &lt;p&gt;Docker Compose에 대한 설명과 사용법에 대해서 알아본다.&lt;br /&gt;
Docker Compose 란?&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;여러개의 컨테이너를 실행하기 위해 정의되는 툴이다.&lt;/li&gt;
    &lt;li&gt;YAML 파일을 이용하여 각 컨테이너를 정의한다.&lt;/li&gt;
    &lt;li&gt;단일 커맨드를 이용하여 정의한 compose 파일의 서비스들을 실행하거나 중지할 수 있다.&lt;/li&gt;
    &lt;li&gt;어플리케이션의 생명주기를 관리하기 위해 아래와 같은 기능을 제공한다.
      &lt;ul&gt;
        &lt;li&gt;start, stop, rebuild&lt;/li&gt;
        &lt;li&gt;실행중인 서비스들의 상태 확인&lt;/li&gt;
        &lt;li&gt;실행중인 서비스들의 로그 확인&lt;/li&gt;
        &lt;li&gt;서비스에서 일회성 명령실행&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;compose-예제&quot;&gt;Compose 예제&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;참여했던 블록체인 프로젝트를 이용하여 Compose 예제를 작성한다.&lt;/li&gt;
  &lt;li&gt;블록체인은 트랜잭션을 발생시키면 해당 트랜잭션이 최종적으로 블록에 포함되어 합의를 이룬후 처리된다.&lt;/li&gt;
  &lt;li&gt;트랜잭션의 처리 결과에 대해서 조회하는 API를 제공하게 되는데 이부분을 Redis를 이용하여 처리한다.&lt;/li&gt;
  &lt;li&gt;현재 프로젝트는 Redis와 연동하는 부분은 존재하지 않지만 결국 블록체인의 한계로 인해 기존의 솔루션들을 결합해야 할 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;소스코드 체크아웃&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 해당 프로제트에는 이미 Dockerfile이 존재한다.&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git clone https://github.com/xbctechnologies/go-xblockchain.git xnode
&lt;span class=&quot;c&quot;&gt;# 테스트를 위한 keystore 압축해제&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;unzip xnode/test/keystore.zip &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; xnode/ &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;xnode
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;간단하게 2개의 서비스(Container)를 정의하는 간단한 Compose 파일을 작성한다.&lt;br /&gt;
해당 Compose 파일을 실행하면 2개의 컨테이너를 실행하게 된다.&lt;br /&gt;
해당 파일은 위에서 체크아웃한 디렉토리 안에 작성한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;docker-compose.yml 작성&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;3'&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;xnode&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;.&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 현재 디렉토리의 Dockerfile을 이용하여 이미지를 빌드&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
     &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;7979:7979&quot;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 컨테이너의 Port와 Host의 Port를 매핑&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--singlenet --rpcwhitelist * --verbosity 4 --keystore /go-xblockchain/keys/keystore --password /go-xblockchain/keys/password --validatorpassword /go-xblockchain/keys/val_password --unlock 0x51e5ae98cd821fa044d1eb49f03fb81a7acf3617,0xa809913b5a5193b477c51b4ba4aa0e1268ed6d13,0xdb0c9f45be6b121aaeef9e382320e0b156487b57 --validatoraddrlist 1T:0xdb0c9f45be6b121aaeef9e382320e0b156487b57&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;links&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;redis&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;volumes&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
     &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;/data/xnode:/root/xnode&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;redis&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;redis:alpine&quot;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# Docker hub로부터 이미지를 다운로드&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Compose Command&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 서비스 시작 (-d : detached)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker-compose up &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 서비스 정지&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker-compose down

&lt;span class=&quot;c&quot;&gt;# 서비스 확인&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker-compose ps

&lt;span class=&quot;c&quot;&gt;# 그외 커맨드 확인&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker-compose &lt;span class=&quot;nt&quot;&gt;--help&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>전성종</name>
        
        
      </author>

      

      
        <category term="docker" />
      

      
        <summary type="html">Docker Compose에 대한 설명과 사용법에 대해서 알아본다. Docker Compose 란? 여러개의 컨테이너를 실행하기 위해 정의되는 툴이다. YAML 파일을 이용하여 각 컨테이너를 정의한다. 단일 커맨드를 이용하여 정의한 compose 파일의 서비스들을 실행하거나 중지할 수 있다. 어플리케이션의 생명주기를 관리하기 위해 아래와 같은 기능을 제공한다. start, stop, rebuild 실행중인 서비스들의 상태 확인 실행중인 서비스들의 로그 확인 서비스에서 일회성 명령실행</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Docker Network</title>
      <link href="https://alexonepath.github.io/category/docker/guide/guide-2-network.html" rel="alternate" type="text/html" title="Docker Network" />
      <published>2018-12-21T09:00:00+09:00</published>
      <updated>2018-12-21T09:00:00+09:00</updated>
      <id>https://alexonepath.github.io/category/docker/guide/guide-2-network</id>
      <content type="html" xml:base="https://alexonepath.github.io/category/docker/guide/guide-2-network.html">&lt;blockquote&gt;
  &lt;p&gt;Docker에서 컨네이너가 사용하는 네트워크 방식에 대해서 알아본다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;docker-network-종류&quot;&gt;Docker Network 종류&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Bridge
    &lt;ul&gt;
      &lt;li&gt;기본 네트워크 드라이버이고 Docker 설치후 Network Interface를 보면 docker0가 생긴것을 볼 수 있다.&lt;/li&gt;
      &lt;li&gt;컨테이너에 특정한 네트워크를 설정하지 않으면 Container의 interface가 하나씩 연결된다.&lt;/li&gt;
      &lt;li&gt;Container가 외부로 통신할 때는 docker0 interface를 거치게 된다.&lt;/li&gt;
      &lt;li&gt;docker0 인터페이스는 host의 eth0 인터페이스와 연결된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Host
    &lt;ul&gt;
      &lt;li&gt;host 방식은 컨테이너 생성시 독립적인 네트워크를 갖지 않고 host의 네트워크와 함께 사용하게 된다.&lt;/li&gt;
      &lt;li&gt;--net=host 옵션으로 컨테이너를 실행한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Overlay
    &lt;ul&gt;
      &lt;li&gt;Docker Swarm에 참여하는 Docker Daemon과 Swarm안의 서비스들 사이에 통신을 담당&lt;/li&gt;
      &lt;li&gt;물리적으로 나누어진 서버가 2대 있고 각 서버의 컨테이너끼리 통신을 하고자 하는 경우 통신을 할 수 없게된다. (포트포워딩을 통해 가능.)&lt;/li&gt;
      &lt;li&gt;이때 여러 서버를 하나의 네트워크로 구성해주는게 Overlay이다. (각 서버에서 실행된 컨네이너는 같은 Gateway와 IP 대역을 가지게 된다.)&lt;/li&gt;
      &lt;li&gt;&lt;span class=&quot;main&quot;&gt;Docker Swarm을 사용하고 물리적으로 분리된 노드에 실행중인 컨테이너 사이에 통신이 필요한 경우 사용.&lt;/span&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;macvlan
    &lt;ul&gt;
      &lt;li&gt;macvlan은 bridge가 없고 host의 물리장비인 eth0 하위에 여러개의 하위 인터페이스를 만들어서 여러개의 Mac 주소를 가지게한다.&lt;/li&gt;
      &lt;li&gt;하위 인터페이스에 컨테이너들이 연결되면서 VLAN 환경을 구성하게 된다.&lt;/li&gt;
      &lt;li&gt;즉, 하나의 네트워크 인터페이스 카드를 가상화 함으로써 여러개의 MAC 주소를 생성하여 사용한다.&lt;/li&gt;
      &lt;li&gt;macvlan 방식은 private, VEPA, Bridge, Passthru 4가지 방식이 있고, Docker에서는 Bridge 방식만 사용한다.&lt;/li&gt;
      &lt;li&gt;Bridge 방식은 Host와는 통신이 안되지만 하위 인터페이스와는 통신이 되는 방식이다.&lt;/li&gt;
      &lt;li&gt;&lt;span class=&quot;main&quot;&gt;높은 처리량과 CPU 사용량이 적은 장점이 있으므로 컨테이너 사이에 통신만 필요한 경우 사용.&lt;/span&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;none
    &lt;ul&gt;
      &lt;li&gt;모든 Netwoking을 사용하지 않는다.&lt;/li&gt;
      &lt;li&gt;none은 Docker Swarm 서비드들에 대해서는 사용불가 하다.&lt;/li&gt;
      &lt;li&gt;&lt;span class=&quot;main&quot;&gt;none으로 설정한 경우는 Custom 네트워크 드라이버를 만들어 사용하는 경웨 사용.&lt;/span&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;컨테이너-연결&quot;&gt;컨테이너 연결&lt;/h3&gt;
&lt;p&gt;도커가 컨테이너를 띄울때 해당 컨테이너는 내부IP를 가지게 되고, 새로 띄울때는 IP가 변경되게 된다.&lt;br /&gt;
예전에는 --link 옵션을 주어서 컨테이너를 연결하였으나 현재는 deprecated 상태이며, 제거될 것이다. &lt;a href=&quot;https://docs.docker.com/network/links/&quot; target=&quot;_blank&quot;&gt;참고&lt;/a&gt;&lt;br /&gt;
--link 옵션을 사용하는 대신 Docker의 Network 기능을 이용하여 처리한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;예제&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# network 생성&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker network create ex-net

&lt;span class=&quot;c&quot;&gt;# network 확인&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker network &lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# network 상세정보 확인&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker network inspect ex-net

&lt;span class=&quot;c&quot;&gt;# 컨테이너 실행시 --network NETWORK-NAME 옵션을 추가한다.&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 아래와 같이 같은 network로 설정을 하면 컨네이터 사이에 통신이 가능하다.&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;--rm&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; mysql-container &lt;span class=&quot;nt&quot;&gt;--network&lt;/span&gt; ex-net mysql
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;--rm&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--network&lt;/span&gt; ex-net apache

&lt;span class=&quot;c&quot;&gt;# 만약 MySQL 컨테이너를 띄우고 소스코드 내에서 MySQL 컨네이너에 접속할때는 아래와 같이 작성한다.&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# jdbc:mysql://mysql-container:3306/test&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Overlay 네트워크 예제&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# overlay 네트워크 생성 (docker swarm manager 노드에서 해야 한다.)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Docker Swarm은 manager노드와 worker 노드가 존재한다.&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker swarm init
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker network create &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; overlay ex-over

&lt;span class=&quot;c&quot;&gt;# 컨테이너 생성&lt;/span&gt;
docker service create &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; myservice &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--network&lt;/span&gt; ex-over &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--replicas&lt;/span&gt; 3 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; ubuntu sleep infinity
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>전성종</name>
        
        
      </author>

      

      
        <category term="docker" />
      

      
        <summary type="html">Docker에서 컨네이너가 사용하는 네트워크 방식에 대해서 알아본다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Docker 기본개념</title>
      <link href="https://alexonepath.github.io/category/docker/guide/guide-1-basic.html" rel="alternate" type="text/html" title="Docker 기본개념" />
      <published>2018-12-20T09:00:00+09:00</published>
      <updated>2018-12-20T09:00:00+09:00</updated>
      <id>https://alexonepath.github.io/category/docker/guide/guide-1-basic</id>
      <content type="html" xml:base="https://alexonepath.github.io/category/docker/guide/guide-1-basic.html">&lt;blockquote&gt;
  &lt;p&gt;로컬, 개발, 운영에 대해서 모두 동일한 환경을 구성할 수 있다.&lt;br /&gt;
순간 트래픽이 증가하거나 하는 경우 새로운 서버에 Docker Engine만 설치하면 빠르게 환경 구축이 가능하다.&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;docker-기본개념&quot;&gt;Docker 기본개념&lt;/h3&gt;
&lt;p&gt;Dockerfile을 이용하여 자신만의 image를 생성하여 Docker Hub 또는 사내 Registry를 구성하여 push한다.&lt;br /&gt;
각 노드는 Registry로부터 이미지를 다운로드 받아서 격리된 컨테이너를 실행할 수 있다.&lt;br /&gt;
기존의 vm 같은 경우는 hypervisor가 hardware를 가상화하고 그위에 새로운 OS가 올라가는 구조이다.&lt;br /&gt;
하지만 Docker의 경우는 OS에 설치된 Docker Engine 위에 어플리케이션(OS 등등) 실행에 필요한 바이너리만 올라가는 구조이기 때문에&lt;br /&gt;
더 적은 자원을 사용할 뿐만 아니라 실행속도 또한 빠르다.&lt;/p&gt;

&lt;p&gt;KUBENETES, DOCKER SWARM, APACHE MESOS 등을 이용하여 컨테이너의 배포 관리를 할 수 있다.(Container Orchestration)&lt;br /&gt;
위의 3가지 솔루션들은 모두 여러 머신들의 자원을 Pool로써 관리하고 새로운 컨테이너가 배포되면 각 노드의 리소스 사용량에 따라&lt;br /&gt;
절적하게 컨테이너를 해당 머신에 배포하여 준다. (서버 자원을 효율적으로 사용할 수 있다.)
&lt;img src=&quot;/assets/images/post/docker/guide/2018-12-20-guide-basic/google-trend.png&quot; alt=&quot;Google trends&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;구글 트렌트 분석
    &lt;ul&gt;
      &lt;li&gt;&lt;span style=&quot;color:#5487eb&quot;&gt;kubenetes&lt;/span&gt;&lt;/li&gt;
      &lt;li&gt;&lt;span style=&quot;color:#c74d40&quot;&gt;docker swarm&lt;/span&gt;&lt;/li&gt;
      &lt;li&gt;&lt;span style=&quot;color:#e8b23f&quot;&gt;mesosphere&lt;/span&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;KUBENETES&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;DOCKER SWARM&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;APACHE MESOS&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;
        &lt;li&gt;Kubernetes의 배포 기본단위는 Pod이라 부른다.&lt;/li&gt;
        &lt;li&gt;각 Pod은 하나 또는 더많은 컨테이너로 구성된다.&lt;/li&gt;
        &lt;li&gt;Pod 안의 모든 컨테이너들은 같은 Host 상에서 스케쥴링 되고&lt;/li&gt;
        &lt;li&gt;localhost loopback 인터페이스를 통해 서로 통신할 수 있다.&lt;/li&gt;
        &lt;li&gt;스케쥴링 이란?&lt;/li&gt;
        &lt;li&gt;Pod 사용하는 리소스(CPU, Memory)에 따라 적절한 host를 선택하여 배정한다.&lt;/li&gt;
      &lt;/td&gt;
      &lt;td&gt;
        &lt;li&gt;Docker Compose 파일을 사용하여 정의한다.&lt;/li&gt;
        &lt;li&gt;Docker Swarm 클러스터에 리소스 사용량에 따라 배정한다.&lt;/li&gt;
      &lt;/td&gt;
      &lt;td&gt;
        &lt;li&gt;Mesos master가 각 agent의 지원을 관리한다.&lt;/li&gt;
        &lt;li&gt;Zookeeper를 이용하여 master 서버 문제시 standby를 leader로 승격&lt;/li&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content>

      
      
      
      
      

      <author>
          <name>전성종</name>
        
        
      </author>

      

      
        <category term="docker" />
      

      
        <summary type="html">로컬, 개발, 운영에 대해서 모두 동일한 환경을 구성할 수 있다. 순간 트래픽이 증가하거나 하는 경우 새로운 서버에 Docker Engine만 설치하면 빠르게 환경 구축이 가능하다.</summary>
      

      
      
    </entry>
  
</feed>
